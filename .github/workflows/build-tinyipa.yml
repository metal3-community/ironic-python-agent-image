name: Build TinyIPA

on:
  push:
    branches: [main, master]
    tags: ["v*"]
  pull_request:
    branches: [main, master]
  release:
    types: [published]

# Prevent concurrent workflow runs
concurrency:
  group: build-ipa

jobs:
  build:
    name: Build TinyIPA (${{ matrix.arch }})
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: true # Fail immediately if any architecture fails
      matrix:
        include:
          - arch: x86_64
            runner: ubuntu-24.04
          - arch: aarch64
            runner: ubuntu-24.04-arm

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.arch == 'x86_64' && '3.9' || '3.11' }}

      - name: Debug environment and fix sudo
        run: |
          echo "Current user: $(whoami)"
          echo "User ID: $(id)"
          echo "Groups: $(groups)"
          ls -l /usr/bin/sudo || echo "sudo not found in /usr/bin/"
          which sudo || echo "sudo not in PATH"

          # Check available Python versions
          echo "Available Python versions:"
          ls -la /usr/bin/python* || echo "No python binaries in /usr/bin"
          python3 --version || echo "python3 not available"
          python3.9 --version || echo "python3.9 not available"
          python3.10 --version || echo "python3.10 not available"
          python3.11 --version || echo "python3.11 not available"
          python3.12 --version || echo "python3.12 not available"

          # Check sudo status
          if sudo --version; then
            echo "sudo is available"
          else
            echo "sudo --version failed"
          fi

          # Try to fix sudo if it's broken
          if ! sudo -n true 2>/dev/null; then
            echo "Attempting to fix sudo configuration..."
            # Try using doas or pkexec as alternatives, or run without sudo
            if command -v doas >/dev/null 2>&1; then
              echo "Using doas as sudo alternative"
              alias sudo=doas
            elif command -v pkexec >/dev/null 2>&1; then
              echo "Using pkexec as sudo alternative"  
              alias sudo=pkexec
            else
              echo "No sudo alternatives found"
            fi
          fi

      - name: Set up environment
        run: |
          # First try normal sudo, if it fails try alternatives
          if sudo apt-get update; then
            echo "sudo is working normally"
          else
            echo "sudo failed, trying alternatives..."
            # Check if we're already root
            if [ "$(id -u)" = "0" ]; then
              echo "Running as root, creating sudo alias"
              echo '#!/bin/bash' > /tmp/fake-sudo
              echo 'exec "$@"' >> /tmp/fake-sudo
              chmod +x /tmp/fake-sudo
              export PATH="/tmp:$PATH"
              alias sudo=/tmp/fake-sudo
              apt-get update
            else
              echo "Not root and sudo failed, this may cause issues"
              apt-get update || echo "apt-get update failed"
            fi
          fi

          # Install packages (try with and without sudo)
          if command -v sudo >/dev/null && sudo -n true 2>/dev/null; then
            sudo apt-get install -y \
              build-essential \
              wget \
              curl \
              cpio \
              gzip \
              tar \
              squashfs-tools \
              xorriso \
              git \
              python3 \
              python3-pip \
              python3-dev \
              python3-setuptools \
              python3-wheel \
              kpartx \
              parted \
              util-linux
          else
            apt-get install -y \
              build-essential \
              wget \
              curl \
              cpio \
              gzip \
              tar \
              squashfs-tools \
              xorriso \
              git \
              python3 \
              python3-pip \
              python3-dev \
              python3-setuptools \
              python3-wheel \
              kpartx \
              parted \
              util-linux
          fi

      - name: Setup Python environment
        run: |
          echo "Setting up Python environment for TinyIPA build..."

          # First, try to install python3.11 if it's not available
          if ! python3.11 --version 2>/dev/null; then
            echo "Python 3.11 not found, trying to install it..."
            if command -v sudo >/dev/null && sudo -n true 2>/dev/null; then
              sudo apt-get update
              sudo apt-get install -y software-properties-common
              sudo add-apt-repository -y ppa:deadsnakes/ppa || echo "PPA add failed, continuing..."
              sudo apt-get update
              sudo apt-get install -y python3.11 python3.11-dev python3.11-venv || echo "Python 3.11 install failed"
            else
              apt-get update
              apt-get install -y software-properties-common
              add-apt-repository -y ppa:deadsnakes/ppa || echo "PPA add failed, continuing..."
              apt-get update
              apt-get install -y python3.11 python3.11-dev python3.11-venv || echo "Python 3.11 install failed"
            fi
          fi

          # Check what Python versions we have now
          echo "Available Python versions after setup:"
          for py in python3 python3.9 python3.10 python3.11 python3.12; do
            if command -v $py >/dev/null; then
              echo "$py: $($py --version)"
            else
              echo "$py: not available"
            fi
          done

          # Find the best available Python version and create symlinks
          if command -v python3.11 >/dev/null; then
            PYTHON_VERSION="python3.11"
          elif command -v python3.10 >/dev/null; then
            PYTHON_VERSION="python3.10"
          elif command -v python3.9 >/dev/null; then
            PYTHON_VERSION="python3.9"
          else
            PYTHON_VERSION="python3"
          fi

          echo "Using Python version: $PYTHON_VERSION"
          echo "TINYIPA_PYTHON_EXE=$PYTHON_VERSION" >> $GITHUB_ENV

          # Create symlinks for consistency
          if [ "$PYTHON_VERSION" != "python3.11" ] && ! command -v python3.11 >/dev/null; then
            echo "Creating python3.11 symlink to $PYTHON_VERSION"
            if command -v sudo >/dev/null && sudo -n true 2>/dev/null; then
              sudo ln -sf $(which $PYTHON_VERSION) /usr/local/bin/python3.11
            else
              mkdir -p /tmp/python-links
              ln -sf $(which $PYTHON_VERSION) /tmp/python-links/python3.11
              echo "/tmp/python-links" >> $GITHUB_PATH
            fi
          fi

      # Install isolinux/syslinux only for x86_64
      - name: Install x86_64 boot tools
        if: matrix.arch == 'x86_64'
        run: |
          sudo apt-get install -y \
            isolinux \
            syslinux-utils

      - name: Install dependencies
        run: |
          ./install-deps.sh

      - name: Set architecture environment
        run: |
          echo "ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
          echo "IPA_SOURCE_DIR=/opt/stack/ironic-python-agent" >> $GITHUB_ENV
          echo "Building for architecture: ${{ matrix.arch }}"

      - name: Clone ironic-python-agent
        run: |
          # Create directory with proper permissions
          if command -v sudo >/dev/null && sudo -n true 2>/dev/null; then
            sudo mkdir -p /opt/stack
            sudo chown $(whoami):$(id -g) /opt/stack
          else
            mkdir -p /opt/stack || echo "mkdir failed, trying without sudo"
          fi
          git clone https://github.com/openstack/ironic-python-agent.git /opt/stack/ironic-python-agent

      - name: Build TinyIPA
        run: |
          export ARCH=${{ matrix.arch }}
          make build

      - name: Finalise TinyIPA
        run: |
          export ARCH=${{ matrix.arch }}
          make finalise

      - name: Build ISO (x86_64 only)
        if: matrix.arch == 'x86_64'
        run: |
          export ARCH=${{ matrix.arch }}
          make iso

      - name: Create architecture-specific artifacts
        run: |
          # Find the actual generated files (they may have branch extensions)
          for base in tinyipa*.gz tinyipa*.vmlinuz tinyipa*.tar.gz tinyipa*.iso; do
            if [ -f "$base" ]; then
              # Extract the extension part (everything after tinyipa)
              ext="${base#tinyipa}"
              # Create architecture-specific name
              newname="tinyipa-${{ matrix.arch }}${ext}"
              mv "$base" "$newname"
              echo "Renamed $base to $newname"
            fi
          done

          # Create checksums for all tinyipa-arch files
          for f in tinyipa-${{ matrix.arch }}.*; do
            if [ -f "$f" ] && [[ ! "$f" == *.sha256 ]]; then
              sha256sum "$f" > "$f.sha256"
              echo "Created checksum for $f"
            fi
          done

      - name: List built artifacts
        run: |
          echo "Built artifacts:"
          ls -la tinyipa-${{ matrix.arch }}.*
          echo "File sizes:"
          du -h tinyipa-${{ matrix.arch }}.*

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: tinyipa-${{ matrix.arch }}
          path: |
            tinyipa-${{ matrix.arch }}.*
          retention-days: 7

  publish:
    name: Publish to Release
    needs: build
    runs-on: ubuntu-24.04
    if: github.event_name == 'release' && github.event.action == 'published'

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          find artifacts -name "tinyipa-*" -type f | while read file; do
            cp "$file" release-assets/
          done

          echo "Release assets:"
          ls -la release-assets/

      - name: Upload release assets
        uses: softprops/action-gh-release@v2
        with:
          files: release-assets/*
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-latest:
    name: Update Latest Release
    needs: build
    runs-on: ubuntu-24.04
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare latest assets
        run: |
          mkdir -p latest-assets
          find artifacts -name "tinyipa-*" -type f | while read file; do
            cp "$file" latest-assets/
          done

          echo "Latest assets:"
          ls -la latest-assets/

      - name: Delete existing latest release
        continue-on-error: true
        run: |
          gh release delete latest --yes || true
          git push origin --delete latest || true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create latest release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest
          name: Latest TinyIPA Build
          body: |
            Latest automated build of TinyIPA for multiple architectures.

            Built from commit: ${{ github.sha }}

            ## Architectures
            - **x86_64**: Intel/AMD 64-bit systems
            - **aarch64**: ARM 64-bit systems (ARM64)

            ## Files
            - `tinyipa-{arch}.gz`: Root filesystem image
            - `tinyipa-{arch}.vmlinuz`: Linux kernel
            - `tinyipa-{arch}.tar.gz`: Combined package
            - `tinyipa-x86_64.iso`: Bootable ISO (x86_64 only)
            - `*.sha256`: Checksums for verification
          files: latest-assets/*
          prerelease: false
          draft: false
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
